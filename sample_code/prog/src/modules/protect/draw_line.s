;************************************************************************
;	直線の描画
;========================================================================
;■書式		: void draw_line(X0, Y0, X1, Y1, color);
;
;■引数
;	X0		: 始点のX座標
;	Y0		: 始点のY座標
;	X1		: 終点のX座標
;	Y1		: 終点のY座標
;	color	: 描画色
;
;■戻り値	: 無し
;************************************************************************
draw_line:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; ---------------
												;    +24| 色
												;    +20| Y1
												;    +16| X1
												;    +12| Y0
												;    + 8| X0
												; ---------------
		push	ebp								; EBP+ 4| EIP（戻り番地）
		mov		ebp, esp						; EBP+ 0| EBP（元の値）
												; ---------------
		push	dword 0							;    - 4| sum   = 0; // 相対軸の積算値
		push	dword 0							;    - 8| x0    = 0; // X座標
		push	dword 0							;    -12| dx    = 0; // X増分
		push	dword 0							;    -16| inc_x = 0; // X座標増分(1 or -1)
		push	dword 0							;    -20| x0    = 0; // Y座標
		push	dword 0							;    -24| dx    = 0; // Y増分
		push	dword 0							;    -28| inc_x = 0; // Y座標増分(1 or -1)
												; ------|--------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

		;---------------------------------------
		; 幅を計算（X軸）
		;---------------------------------------
		mov		eax, [ebp + 8]					; EAX = X0;
		mov		ebx, [ebp +16]					; EBX = X1;
		sub		ebx, eax						; EBX = X1 - X0; // 幅
		jge		.10F							; if (幅 < 0)
												; {
		neg		ebx								;   幅   *= -1;
		mov		esi, -1							;   // X座標の増分
		jmp		.10E							; }
.10F:											; else
												; {
		mov		esi, 1							;   // X座標の増分
.10E:											; }

		;---------------------------------------
		; 高さを計算（Y軸）
		;---------------------------------------
		mov		ecx, [ebp +12]					; ECX = Y0
		mov		edx, [ebp +20]					; EDX = Y1
		sub		edx, ecx						; EDX = Y1 - Y0; // 高さ
		jge		.20F							; if (高さ < 0)
												; {
		neg		edx								;   高さ *= -1;
		mov		edi, -1							;   // Y座標の増分
		jmp		.20E							; }
.20F:											; else
												; {
		mov		edi, 1							;   // Y座標の増分
.20E:											; }

		;---------------------------------------
		; X軸
		;---------------------------------------
		mov		[ebp - 8], eax					;   // X軸:開始座標
		mov		[ebp -12], ebx					;   // X軸:描画幅
		mov		[ebp -16], esi					;   // X軸:増分(基準軸：1 or -1)

		;---------------------------------------
		; Y軸
		;---------------------------------------
		mov		[ebp -20], ecx					;   // Y軸:開始座標
		mov		[ebp -24], edx					;   // Y軸:描画幅
		mov		[ebp -28], edi					;   // Y軸:増分(基準軸：1 or -1)

		;---------------------------------------
		; 基準軸を決める
		;---------------------------------------
		cmp		ebx, edx						; if (幅 <= 高さ)
		jg		.22F							; {
												;   
		lea		esi, [ebp -20]					;   // X軸が基準軸
		lea		edi, [ebp - 8]					;   // Y軸が相対軸
												;   
		jmp		.22E							; }
.22F:											; else
												; {
		lea		esi, [ebp - 8]					;   // Y軸が基準軸
		lea		edi, [ebp -20]					;   // X軸が相対軸
.22E:											; }

		;---------------------------------------
		; 繰り返し回数(基準軸のドット数)
		;---------------------------------------
		mov		ecx, [esi - 4]					; ECX = 基準軸描画幅;
		cmp		ecx, 0							; if (0 == ECX)
		jnz		.30E							; {
		mov		ecx, 1							;   ECX = 1;
.30E:											; }

		;---------------------------------------
		; 線を描画
		;---------------------------------------
.50L:											; do
												; {
%ifdef	USE_SYSTEM_CALL
		mov		eax, ecx						;   // 繰り返し回数を保存

		mov		ebx, [ebp +24]					;   EBX = 表示色;
		mov		ecx, [ebp - 8]					;   ECX = X座標;
		mov		edx, [ebp -20]					;   EDX = Y座標;
		int		0x82							;   sys_call(1, X, Y, 色, 文字); BX(C), CX(X), DX(Y)

		mov		ecx, eax
%else
		cdecl	draw_pixel, dword [ebp - 8], \
							dword [ebp -20], \
							dword [ebp +24]		;   // 点の描画
%endif
												;   // 基準軸を更新(1ドット分)
		mov		eax, [esi - 8]					;   EAX = 基準軸増分(1 or -1);
		add		[esi - 0], eax					;   

												;   // 相対軸を更新
		mov		eax, [ebp - 4]					;   EAX  = sum; // 相対軸の積算値;
		add		eax, [edi - 4]					;   EAX += dy;  // 増分(相対軸の描画幅)
		mov		ebx, [esi - 4]					;   EBX  = dx;  // 増分(基準軸の描画幅)

		cmp		eax, ebx						;   if (積算値 <= 相対軸の増分)
		jl		.52E							;   {
		sub		eax, ebx						;     EAX -= EBX; // 積算値から相対軸の増分を減算
												;     
												;     // 相対軸の座標を更新(1ドット分)
		mov		ebx, [edi - 8]					;     EBX =  相対軸増分;
		add		[edi - 0], ebx					;     
.52E:											;   }
		mov		[ebp - 4], eax					;   // 積算値を更新
												;   
		loop	.50L							;   
.50E:											; } while (ループ回数--);

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		edi
		pop		esi
		pop		edx
		pop		ecx
		pop		ebx
		pop		eax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		esp, ebp
		pop		ebp

		ret

