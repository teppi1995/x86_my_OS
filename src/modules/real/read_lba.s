lba_chs:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; ------|--------
												;    + 8| LBA（2バイト）
												;    + 6| drv_chsドライブ情報
												;    + 4| driveドライブ情報
												; ------+--------
												;    + 2| IP（戻り番地）
		push	bp								;  BP+ 0| BP（元の値）
		mov		bp, sp							; ------+--------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	ax
		push	bx
		push	dx
		push	si
		push	di

		;---------------------------------------
		; 【処理の開始】
		;---------------------------------------
		mov		si, [bp + 4]					; SI  = driveバッファ;
		mov		di, [bp + 6]					; DI  = drv_chsバッファ;

		; シリンダあたりのセクタ数を計算（ヘッド数×セクタ数）
		mov		al,  [si + drive.head]			; AL = 最大ヘッド数;
		mul		byte [si + drive.sect]			; AX = 最大ヘッド数 * 最大セクタ数;
		mov		bx, ax							; BX = シリンダあたりのセクタ数;

		; シリンダ番号を取得するために
		; LBAをシリンダあたりのセクタ数で除算
		mov		dx, 0							; DX = LBA（上位2バイト）
		mov		ax,  [bp + 8]					; AX = LBA（下位2バイト）
		div		bx								; DX = DX:AX % BX; // 残り
												; AX = DX:AX / BX; // シリンダ番号

		mov		[di + drive.cyln], ax			; drv_chs.cyln = シリンダ番号;

		; ヘッド位置を取得するために
		; あまりをトラックあたりのセクタ数で除算
		mov		ax, dx							; AX = 残り
		div		byte [si + drive.sect]			; AH = AX % 最大セクタ数; // セクタ番号
												; AL = AX / 最大セクタ数; // ヘッド番号

		movzx	dx, ah							; DX = セクタ番号
		inc		dx								; （セクタは1始まりなので+1）

		mov		ah, 0x00						; AX = ヘッド位置

		mov		[di + drive.head], ax			; drv_chs.head = ヘッド番号;
		mov		[di + drive.sect], dx			; drv_chs.sect = セクタ番号;

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		di
		pop		si
		pop		dx
		pop		bx
		pop		ax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		sp, bp
		pop		bp

		ret

read_lba:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; ------|--------
												;    +10| コピー先
												;    + 8| セクタ数
												;    + 6| LBA（2バイト）
												;    + 4| ドライブ情報
												; ------+--------
												;    + 2| IP（戻り番地）
		push	bp								;  BP+ 0| BP（元の値）
		mov		bp, sp							; ------+--------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	si

		;---------------------------------------
		; 【処理の開始】
		;---------------------------------------
		mov		si, [bp + 4]					; SI = ドライブ情報;

		;---------------------------------------
		; LBA→CHS変換
		;---------------------------------------
		mov		ax, [bp + 6]					; AX = LBA;
		cdecl	lba_chs, si, .chs, ax			; lba_chs(drive, .chs, AX);

		;---------------------------------------
		; ドライブ番号のコピー
		;---------------------------------------
		mov		al, [si + drive.no]				; 
		mov		[.chs + drive.no], al			; ドライブ番号

		;---------------------------------------
		; セクタの読み込み
		;---------------------------------------
		cdecl	read_chs, .chs, word [bp + 8], word [bp +10]
												; AX = read_chs(.chs, セクタ数, ofs);

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		si

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		sp, bp
		pop		bp

		ret

ALIGN 2
.chs:	times drive_size	db	0				; 読み込みセクタに関する情報
